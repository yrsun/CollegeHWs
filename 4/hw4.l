;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Your solution goes in this file ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun all-length (l)
    (cond ((null l) 0)
          (t (+ (cond ((listp (car l)) (all-length(car l)))
                      (t 1))
                (all-length(cdr l))))))
                
(defun range(l)
    (cons (apply 'min l) (cons (apply 'max l) nil)))
    
(defun before(a b l)
    (cond  ((null l) nil)
            ((setq flaga 0)
            (setq c (cons a nil))
            (dolist (x l)
                (cond   ((equal flaga 0)
                    (cond   ((equal a x) (setq flaga 1))))
                        ((equal flaga 1)
                    (cond ((equal b x) (setq c(cons b c)) (return))
                          ((equal nil x) (return))
                          ((and (not(equal b x))(not(equal nil x))) (setq c(cons x c)))))
                )
            )
            (setq c (reverse c)) 
          )
    )
)

(defun split-if(fun l)
    (setq a nil)
    (setq b nil)
    (cond ((null l) (setq c(list a b)))
          ((listp l)
    (dolist (x l)
    (cond ((funcall fun(car (list x))) (setq a(cons x a)))
          ((not(funcall fun(car (list x)))) (setq b(cons x b)))
    ))
    (setq a(reverse a))
    (setq b(reverse b))
    (setq c(list b a))))
)

(defun group(l n)
    (setq m 0)
    (setq a nil)
    (setq b nil)
    (dolist (x l)
    (cond ((equal m n) (setq m 1) (setq a(reverse a)) (setq b(cons a b)) (setq a nil) (setq a(cons x a)))
          ((not(equal m n)) (setq m(1+ m)) (setq a(cons x a)))
    ))
    (cond ((null a) (reverse b))
          ((not(null a)) (setq a(reverse a)) (setq b(cons a b)) (reverse b)))
)

(defun mostn(fun l)
    (setq s 0)
    (setq a nil)
    (dolist (x l)
    (cond ((> (funcall fun(car (list x))) s) (setq a nil) (setq a(cons x a)) (setq s (funcall fun(car (list x)))))
          ((= (funcall fun(car (list x))) s) (setq a(cons x a)))
          ((< (funcall fun(car (list x))) s) ))
    )
    (setq a(reverse a))
    (setq a(list a))
    (setq a(cons s a))
    (setq a(reverse a))
)

(defun match(l k)
    (setq sol 't)
    (setq flag 0)
    (setq def 0)
    (dolist (y k)
        (cond ((null l) (cond ((= flag 0) (setq sol 'nil))
                              ((= flag 1) (setq sol 't))))
              ((and (not(equal (car l) '?)) (not(equal (car l) '!))) 
                (cond ((= flag 0) (cond ((equal (car l) y) (setq l(cdr l)) )
                                        ((not(equal (car l) y)) (setq sol 'nil) (setq def 1))))
                      ((= flag 1) (cond ((equal (car l) y) (setq l(cdr l)) (setq flag 0))
                                        ((not(equal (car l) y)) )))
                )  
              )
              ((equal (car l) '?) (setq l(cdr l)))
              ((equal (car l) '!) (setq flag 1) (setq l(cdr l)))
        )
    )
    (cond ((or (not (null l)) (equal def 1)) (setq sol nil))
    )
    sol
)

(defun match-var(l k)
    (setq sol 't)
    (setq flag 0)
    (setq s 'jicuo)
    (setq gan 0)
    (setq gl 'nil)
    (setq def 0)
    (dolist (y k)
        (cond ((null l) (cond ((= flag 0) (setq sol 'nil))
                              ((= flag 1) (setq sol 't))))
              ((atom (car l)) 
                (cond ((= flag 0) (cond ((equal s y) )
                                        ((equal (car l) y) (setq l(cdr l)) (setq s 'jicuo) )
                                        ((not(equal (car l) y)) (setq sol 'nil) (setq def 1) )))
                      ((= flag 1) (cond ((equal (car l) y) (cond ((equal y (car gl))(setq gl (cons y gl)) (set gan (reverse gl))))(setq s (car l)) (setq l(cdr l)) (setq flag 0) )
                                        ((not(equal (car l) y))(setq gl (cons y gl)) (set gan (reverse gl)))))
                )  
              )
              ((listp (car l)) (cond ((equal s y) )
                ((equal (caar l) '?) (set (cadar l) y)(setq l(cdr l))(setq s 'jicuo))
                ((equal (caar l) '!) (setq gan (cadar l)) (set gan (list y))(setq gl (cons y gl)) (setq flag 1) (setq l(cdr l)))
                               )
              )
        )
    )
    (cond ((or (not (null l)) (equal def 1)) (setq sol nil))
    )
    sol
)